# 인하대학교 항공우주공학과 선형대수학 2023 기말고사 2번 문제 풀이

date: 2025년 3월 16일
slug: ase2010_final_exam_2
author: jinwoo im
status: Public
tags: Linear Control
summary: Soft landing of a reusable launcher
이산 시간 선형 동적 시스템은 아래와 같이 시간 t𝑡 (t∈{0,…,N−1}𝑡∈{0,…,𝑁−1})에 따른 상태 벡터 xt∈Rn𝑥𝑡∈𝑅𝑛 와 제어 입력 ut∈Rm𝑢𝑡∈𝑅𝑚으로 표현한다.xt+1=Axt+But𝑥𝑡+1=𝐴𝑥𝑡+𝐵𝑢𝑡A𝐴는 상태 천이 행렬이며, B𝐵는 입력 행렬이다. A𝐴와 B𝐵가 주어졌을 때, 우리의 목표는 종말 시간에 원하는 상태, 즉 xN=xdes𝑥𝑁=𝑥des을 만족하는 최적의 입력 벡터 u0,…,uN−1𝑢0,…,𝑢𝑁−1를 찾는 것이다. 최소 에너지 ut𝑢𝑡를 찾는 최적화 문제는 아래와 같이 기술할 수 있다.
type: Post
updatedAt: 2025년 3월 16일 오후 6:48
category: 📗 LinearAlgebra

# 2023 ASE 2010 final exam 문제 풀이

![Untitled](%EC%9D%B8%ED%95%98%EB%8C%80%ED%95%99%EA%B5%90%20%ED%95%AD%EA%B3%B5%EC%9A%B0%EC%A3%BC%EA%B3%B5%ED%95%99%EA%B3%BC%20%EC%84%A0%ED%98%95%EB%8C%80%EC%88%98%ED%95%99%202023%20%EA%B8%B0%EB%A7%90%EA%B3%A0%EC%82%AC%202%EB%B2%88%20%EB%AC%B8%EC%A0%9C%20%ED%92%80%EC%9D%B4%207f462aa32d6d46e8b7038babd1d96726/Untitled.png)

![Untitled](%EC%9D%B8%ED%95%98%EB%8C%80%ED%95%99%EA%B5%90%20%ED%95%AD%EA%B3%B5%EC%9A%B0%EC%A3%BC%EA%B3%B5%ED%95%99%EA%B3%BC%20%EC%84%A0%ED%98%95%EB%8C%80%EC%88%98%ED%95%99%202023%20%EA%B8%B0%EB%A7%90%EA%B3%A0%EC%82%AC%202%EB%B2%88%20%EB%AC%B8%EC%A0%9C%20%ED%92%80%EC%9D%B4%207f462aa32d6d46e8b7038babd1d96726/Untitled%201.png)

![Untitled](%EC%9D%B8%ED%95%98%EB%8C%80%ED%95%99%EA%B5%90%20%ED%95%AD%EA%B3%B5%EC%9A%B0%EC%A3%BC%EA%B3%B5%ED%95%99%EA%B3%BC%20%EC%84%A0%ED%98%95%EB%8C%80%EC%88%98%ED%95%99%202023%20%EA%B8%B0%EB%A7%90%EA%B3%A0%EC%82%AC%202%EB%B2%88%20%EB%AC%B8%EC%A0%9C%20%ED%92%80%EC%9D%B4%207f462aa32d6d46e8b7038babd1d96726/Untitled%202.png)

```python
import numpy as np
import matplotlib.pyplot as plt

N = 200
tf = 20
ts = np.linspace(0,tf,N+1)
dt = tf/N
gamma = .05
g = 9.8

A = np.array([[1, 0, (1-0.5*gamma*dt)*dt,                   0],
              [0, 1,                   0, (1-0.5*gamma*dt)*dt],
              [0, 0,        (1-gamma*dt),                   0],
              [0, 0,                   0,        (1-gamma*dt)]])
B = np.array([[0.5*dt**2,         0],
              [        0, 0.5*dt**2],
              [       dt,         0],
              [        0,        dt]])
b = np.array([0, -0.5*g*dt**2, 0, -g*dt])

x0 = np.array([-200, 2000, 40, -300])
x_des = np.array([0, 0, 0, 0])
```

## 내 풀이

![Untitled](%EC%9D%B8%ED%95%98%EB%8C%80%ED%95%99%EA%B5%90%20%ED%95%AD%EA%B3%B5%EC%9A%B0%EC%A3%BC%EA%B3%B5%ED%95%99%EA%B3%BC%20%EC%84%A0%ED%98%95%EB%8C%80%EC%88%98%ED%95%99%202023%20%EA%B8%B0%EB%A7%90%EA%B3%A0%EC%82%AC%202%EB%B2%88%20%EB%AC%B8%EC%A0%9C%20%ED%92%80%EC%9D%B4%207f462aa32d6d46e8b7038babd1d96726/Untitled%203.png)

이러한 euclidean norm이 목적함수(objective funtion)으로 정의되어있고, 선형 등식 제약조건이 걸려있다면 위의 문제는 아래와 같은 최적화 문제로 다시 정의된다.

$\begin{aligned}
\underset{u}{\text{minimize}} \quad & \sum_{t=0}^{199} \|u_t\|^2  \\
\text{subject to} \quad & \begin{bmatrix}x_{200}\\ x_{150}\end{bmatrix} = \begin{bmatrix}A^{200}\\ A^{150}\end{bmatrix} x_0 + \begin{bmatrix}A^{199}B & A^{198}B & \cdots & AB & B \\ A^{149}B & A^{148}B & \cdots & 0 & 0\end{bmatrix} \begin{bmatrix}u_0 \\u_1 \\ \vdots \\ u_{t-2} \\ u_{t-1}\end{bmatrix} + \begin{bmatrix}A^{199} & A^{198} & \cdots & A & I \\ A^{149} & A^{148} & \cdots & 0 & 0\end{bmatrix}\begin{bmatrix}b \\b \\ \vdots \\ b \\ b\end{bmatrix}
\end{aligned}$

이때 주어진 목적함수를 minimize하는 $u_{des}$ 는 least norm solution의 결과를 활용하면

$u_{\text{des}} = \left(\begin{bmatrix}A^{199}B & A^{198}B & \cdots & AB & B \\ A^{149}B & A^{148}B & \cdots & 0 & 0\end{bmatrix}\right)^{\dagger} \left( \begin{bmatrix}x_{200}\\ x_{150}\end{bmatrix} - \begin{bmatrix}A^{200}\\ A^{150}\end{bmatrix} x_0 - \begin{bmatrix}A^{199} & A^{198} & \cdots & A & I \\ A^{149} & A^{148} & \cdots & 0 & 0\end{bmatrix}\begin{bmatrix}b \\b \\ \vdots \\ b \\ b\end{bmatrix} \right)$
이다.

이때 목적함수 $\sum_{t=0}^{199} \|u_t\|^2  = u_{\text{des}}^T u_{\text{des}}$
  이고, $\begin{bmatrix}x_{200}\\ x_{150}\end{bmatrix} = \begin{bmatrix}0\\0\\0\\0\\0\\100\\0\\\lambda\end{bmatrix}$이다. 

이때 주어진 목적함수는 $\lambda$ 에 대한 **2차 다항식**이 되고, **$\lambda$에 0,1,2를 대입한 후, 2차 다항식을 구한 후, 2차 다항식을 minimize하는 $\lambda$**를 찾으면 된다.

주어진  $u_{des}$ 를 간단하게 축약해보자.

$u_{des} = G^{\dagger} \left(\begin{bmatrix}0\\0\\0\\0\\0\\100\\0\\\lambda\end{bmatrix} -Z\right)$

G와 Z를 구하는 코드는 다음과 같다.

```python
G = np.zeros((8,2*N))

for i in range(N):
  
  G[:4, 2*i:2*(i+1)] = np.linalg.matrix_power(A,max(0,N-i-1))@B
  if i <150:
    G[4:, 2*i:2*(i+1)] =  np.linalg.matrix_power(A,max(0,N-i-51))@B
  else:
    continue

Z = np.zeros(8)
for i in range(N):
  Z[:4] += np.linalg.matrix_power(A,max(0,N-i-1))@b
  if i < 150:
    Z[4:] += np.linalg.matrix_power(A,max(0,N-i-51))@b
  else:
    continue

Z[:4] += np.linalg.matrix_power(A,200)@x0
Z[4:] += np.linalg.matrix_power(A,150)@x0

#psuedo inverse 정의
psu_G = np.linalg.pinv(G)
```

이때 $\lambda$에 0,1,2를 대입한 후, 2차 다항식을 구한 후, 2차 다항식을 minimize하는 $\lambda$를 찾는 코드는 다음과 같다.

```python
X = np.array([0, 0, 0, 0, 0, 100, 0, 0])
lambda_ = np.array([0, 0, 0, 0, 0, 0, 0, 1])

# Norm을 다시 계산하는 함수 정의
def norm_equation(lam):
    return np.linalg.norm(psu_G  @ (X + lam * lambda_ - Z))**2

# norm에 각각 0,1,2 대입
norm_0 = norm_equation(0)
norm_1 = norm_equation(1)
norm_2 = norm_equation(2)

# 2차 방정식의 계수 구하기
Q = np.array([
    [0**2, 0, 1],
    [1**2, 1, 1],
    [2**2, 2, 1]
])

c = np.array([norm_0, norm_1, norm_2])
coeff = np.linalg.solve(Q, c)
#계수가 양수인, x에 대한 2차 다항식을 minimize하는 x는 -1*1차항의계수/(2*2차항의계수)임을 활용한다.
minimum_y_velocity = -coeff[1]/(2*coeff[0])
print(minimum_y_velocity)
```

 

minimum_y_velocity = 33.11062052290241 이 나왔다.

이를 기반으로 X와 u를 구한 다음 그래프로 출력해보자.

 

```python
u_des = psu_G@(np.array([0,0,0,0,0,100,0,minimum_y_velocity])-Z)
print(u_des)
u = np.zeros((2,200))
current_x = x0
x = np.zeros((4,201))
x[0][0] = x0[0]
x[1][0] = x0[1]
x[2][0] = x0[2]
x[3][0] = x0[3]
for i in range(N):
  u[0][i],u[1][i] = u_des[2*i],u_des[2*i+1]
  current_x = A@current_x + B@np.array([u[0][i],u[1][i]]) + b

  x[0][i+1] = current_x[0]
  x[1][i+1] = current_x[1]
  x[2][i+1] = current_x[2]
  x[3][i+1] = current_x[3]

draw_plots(ts,x,u)
draw_2d_traj(x,u,150)
```

 

![Untitled](%EC%9D%B8%ED%95%98%EB%8C%80%ED%95%99%EA%B5%90%20%ED%95%AD%EA%B3%B5%EC%9A%B0%EC%A3%BC%EA%B3%B5%ED%95%99%EA%B3%BC%20%EC%84%A0%ED%98%95%EB%8C%80%EC%88%98%ED%95%99%202023%20%EA%B8%B0%EB%A7%90%EA%B3%A0%EC%82%AC%202%EB%B2%88%20%EB%AC%B8%EC%A0%9C%20%ED%92%80%EC%9D%B4%207f462aa32d6d46e8b7038babd1d96726/Untitled%204.png)

잘 나오는 것을 볼 수 있다.

[https://www.youtube.com/shorts/xJeZrzILkXs](https://www.youtube.com/shorts/xJeZrzILkXs)

## 풀이에 대한 생각

$\lambda$ 에 대한 2차 다항식을 만드는 것이 어려웠다… Norm은 무조건 Convex이므로, local_minima는 무조건 global_minima가 된다. 

아마 김종한 교수님의 풀이는 조금 더 간결할 것이다…. 내가 너무 무지한 것 같다.

또한 동적 프로그래밍을 사용하여, np.linalg.matrix_power를 단순화 시켜야 한다. 

아마 np.linalg.matrix_power 때문에, 시간 복잡도가 상당히 증가될 것으로 생각된다.

이에 대해서 시간이 난다면, 다시 풀이를 작성해야겠다….

![Untitled](%EC%9D%B8%ED%95%98%EB%8C%80%ED%95%99%EA%B5%90%20%ED%95%AD%EA%B3%B5%EC%9A%B0%EC%A3%BC%EA%B3%B5%ED%95%99%EA%B3%BC%20%EC%84%A0%ED%98%95%EB%8C%80%EC%88%98%ED%95%99%202023%20%EA%B8%B0%EB%A7%90%EA%B3%A0%EC%82%AC%202%EB%B2%88%20%EB%AC%B8%EC%A0%9C%20%ED%92%80%EC%9D%B4%207f462aa32d6d46e8b7038babd1d96726/Untitled%205.png)