# 자동제어 과제 2. Sol

updatedAt: 2025년 3월 23일 오후 5:17

## 1. State-space description.

다음과 같은 미분방정식으로 표현되는 선형 시스템을 생각하자.

$$

\ddot{y}(t) + 2 \dot{y}(t) + y(t)=  \dot{x}(t) + x(t)\\
    \dot{x}(t) + 2x(t) - 2y(t) =u(t)
$$

1. 시스템의 전달함수 $G(s) =\frac{y(s)}{u(s)}$ 를 구하시오.
    - Sol
        
        이 문제에서 중요한 것은 미분 방정식 → 전달함수이다. 
        즉 미분 방정식을 보고 전달함수를 만들 수 있어야 한다.
        
        위 식을 라플라스 변환을 통해 s-domain으로 표현한다면
        
        $$
        (s^2 +2s + 1) Y = (s+1)X\\
        (s+2)X - 2Y = U
        
        $$
        
        이 식을 정리하면 아래와 같이 나온다. 
        
        $$
        (s+1)Y = X\\
        (s+2)X -2Y = U
        $$
        
        첫번째 식을 두번째 식에다가 넣으면 아래와 같은 결과가 나온다. 
        
        $$
        (s+2)(s+1)Y-2Y = U \\
        (s+3)(s)Y = U \\
        G(s) = \frac{1}{(s+3)(s)}
        $$
        
2. 시스템의 

### 1번 문제에서 고찰할 점.

굉장히 간단한 문제여서 넘길 수 있지만 이 문제에는 제어의 핵심이 담겨있다. 

1번 문제에서는 미분방정식 → 전달함수로 바꾸는 것을 연습했다. 

그리고 미분방정식 → 상태공간표현식으로 바꾸는 것도 연습했다. 

이를 반대로 생각해보면 전달함수 → 미분방정식으로 풀 수 있어야 한다!

또한 상태공간 표현식 → 미분방정식으로도 풀 수 있어야 한다. 

### 추가 연습 문제

---

아래는 노즐 각도 $u$를 계산하여, 주어진 각도 명령 $\theta_{cmd}$를 추종하게 하는 $\theta$를 시스템의 출력으로 응답하게 하는 TVC Rocket Control 시스템의 미분 방정식이다.

$I\ddot{\theta} = Tlu$

$\dot{u} + p{u} = K({\dot{\theta}_{cmd}} + z\theta_{cmd}) - K(\dot\theta + z\theta)$

이때 $p,z$는 실수인 상수이다. 

또한 $T$는 로켓의 추력이며, 항상 일정하다고 가정한다.

$l$은 로켓의 노즐부터, 회전 중심까지의 거리이다. 항상 일정하다고 가정한다. 

$I$는 로켓의 관성 모멘트이다. 항상 일정하다고 가정한다. 

a) 이 시스템의 전달함수 $\frac{\theta(s)}{\theta_{cmd}(s)}$를 구하시오

## 2. Transfer function.

어떠한 선형 시스템 G(s)에 대해, 초기조건이 0인 상태에서 입력u(t) = e−t(t ≥ 0)를 가했을 때 출력 응답이 다음과 같았다고 한다.

![image.png](%EC%9E%90%EB%8F%99%EC%A0%9C%EC%96%B4%20%EA%B3%BC%EC%A0%9C%202%20Sol%2018044cd8bc5380b5bcf9f0238fa0735c/image.png)

이 시스템의 전달함수 $G(s) = \frac{Y(s)}{U(s)}$ 를 구하시오

## Sol 1.

$U(s) = \frac{1}{s+1}$ 이다. 

$Y(s) = \frac{1}{s} -  \frac{2}{s+1} +  \frac{s+2}{(s+2)^2 +1}$

$\frac{Y(s)}{U(s)} = \frac{s+1}{s} -2 + \frac{(s+2)(s+1)}{(s+2)^2 +1} =\\
1 + \frac{1}{s} -2 + 1 - \frac{(s+3)}{s^2 + 4s + 5} = 
\\

\frac{1}{s} - \frac{(s+3)}{s^2 + 4s + 5}$

### Sol 2.

$Y(s) = G(s)\frac{1}{s+1}$

이를 생각해보면

$(s+1)Y(s) = G(s)$ 이다. 

즉 이때 왼쪽 항을 라플라스 역변환을 하면

$y(t) + \dot{y(t)}$ 이 된다. 

즉  $\mathcal{L} (y(t) + \dot{y(t)}) =  G(s)$  라 할 수 있고 이를 계산하면

 $\mathcal{L} (1-2e^{-t} + e^{-2t}\cos{t} + 2e^{-t} -2e^{-2t}\cos{t} -e^{-2t}\sin{t}) = \\  \mathcal{L}(-e^{-2t}\cos{t}  -e^{-2t}\sin(t) +1) = \\
\frac{1}{s} - \frac{s+2}{(s+2)^2 + 1} - \frac{1}{(s+2)^2 +1} = \\

\frac{1}{s} - \frac{s+3}{(s+2)^2 + 1}$

이를 보면 Sol1 과 Sol2가 과정은 다르지만 답은 똑같다는 것을 알 수 있다.

## 3. System identification.

다음과 같은 동역학으로 표시되는 1차 시스템이 있다. 

$$
\dot{y}(t) = ay(t) + bu(t)
$$

시스템은 초기에 정지되어 있었으며, 단위스텝입력 $u_s(t)$ 를 가하고, 0.5초 후에 측정된 출력 $y(0.5)$와 시간이 충분히 지난 후, 측정된 출력 $y(\infty)$ 는 각각 다음과 같았다.

$$
y(0.5) = 1, y(\infty) = 2
$$

위의 측정값을 이용하여 시스템 파라미터 a와 b를 결정하시오.

- Sol
    
    어려울 게 없다. 그냥 아래처럼 계산하면 된다!
    
    $$
    \begin{align*}
    (s - a)Y(s)      &= bU(s) \\
    Y(s)             &= \left(\frac{b}{s - a}\right)U(s) \\
    U(s)             &= \frac{1}{s} \\
    Y(s)             &= \left(\frac{b}{s - a}\right)\left(\frac{1}{s}\right) \\
                     &= \frac{b}{a} \left(\frac{1}{s - a} - \frac{1}{s}\right) \\
    y(t)             &= \frac{b}{a} \left(e^{at} - 1\right) \\
    \lim_{t \to \infty} y(t) &= -\frac{b}{a} = 2 \quad \Rightarrow \quad b = -2a \\
    y(t)             &= -2 \left(1 + e^{at}\right) \\
    y(0.5)           &= -2 \left(-1 + e^{0.5a}\right) = 1 \\
    e^{0.5a}         &= \frac{1}{2} \\
    a                &= 2 \ln\left(\frac{1}{2}\right) = -2\ln 2 \\
    b                &= -2a = 4 \ln 2
    \end{align*}
    $$
    

## 4. Drawing exercise.

어떠한 선형 시스템의 전달함수 $G(s)$가 다음과 같이 주어져 있을 때, 아래 물음에 답하시오. 

$$
G(S) = \frac{s^2 - 26}{(s+10)(s^2 + 3s + 4)}
$$

1. 위의 전달함수를 부분분수 전개해서, 두개의 분수 함수의 합 형태로 나타내시오. 
2. (컴퓨터를 사용하지 말고) 각 요소들에 대한 스텝응답을 그리고, $G(s)$의 스텝 응답을 그들의 선형조합(linear Combination)으로 표현하여 그리시오, 

## a. Sol

그냥 -10을 대입해서 쪼개면 된다. 그러면 $\frac{1}{s+10}$의 분자항의 계수는 1이 나오고 다시 계산해보면 $\frac{1}{s^2 - 3s + 4}$ 의 계수는 -3이 나옴을 알 수 있다. 

그래서 $G(s) = \frac{1}{s+10} -\frac{3}{s^2 - 3s + 4}$ 임을 알 수 있다. 

## b. Sol

왜 선형 조합일지를 생각해보면다면 $G(s) = (1)\frac{1}{s+10} + (-3)\frac{1}{s^2 - 3s + 4}$  으로 2개의 function이 1,-3의 계수를 가지는 linear combination으로 해석할 수 있다. 

### 첫번째 항

$G_1(s)U(s) = -\frac{3}{s(s^2 + 3s + 4)}$ 

$\lim_{t \to \infty} y(t) = \lim_{s \to 0^+} s G_1(s) U(s) = \lim_{s \to 0^+} s \left(-\frac{3}{s(s^2 + 3s + 4)}\right)$

$= \lim_{s \to 0^+} \left(-\frac{3}{s^2 + 3s + 4}\right) = -\frac{3}{4}$

이때, 댐핑비와 주파수를 생각해보면 오버슛이 살짝 발생하는 것을 생각해볼 수 있다. 컴퓨터로 계산해보면 아래와 같이 나온다. 

그리고 생략하긴 했지만 앞에 $s$를 곱해 초기 응답의 경향성또한 알 수 있다

![image.png](%EC%9E%90%EB%8F%99%EC%A0%9C%EC%96%B4%20%EA%B3%BC%EC%A0%9C%202%20Sol%2018044cd8bc5380b5bcf9f0238fa0735c/image%201.png)

해석적 식은 아래와 같다. 

![image.png](%EC%9E%90%EB%8F%99%EC%A0%9C%EC%96%B4%20%EA%B3%BC%EC%A0%9C%202%20Sol%2018044cd8bc5380b5bcf9f0238fa0735c/image%202.png)

### 두번째 항

$G_2(s) U(s) = \frac{1}{(s + 10)s} = \left(\frac{1}{s} - \frac{1}{s + 10}\right) \frac{1}{10}$ 

$y_2(t) = \frac{1}{10} - \frac{1}{10}e^{-10t}$

이때 t가 무한대로 가면 0.1로 수렴함을 확인할 수 있다. 

컴퓨터를 이용해 시각화하면

![image.png](%EC%9E%90%EB%8F%99%EC%A0%9C%EC%96%B4%20%EA%B3%BC%EC%A0%9C%202%20Sol%2018044cd8bc5380b5bcf9f0238fa0735c/image%203.png)

이때 이 둘을 선형결합한다면 수렴하는 값은 $\frac{-3}{4} + \frac{1}{10} = \frac{-26}{40}$ 이 된다. 

컴퓨터를 이용해 시각화해보면 아래와 같이 나온다. 

![image.png](%EC%9E%90%EB%8F%99%EC%A0%9C%EC%96%B4%20%EA%B3%BC%EC%A0%9C%202%20Sol%2018044cd8bc5380b5bcf9f0238fa0735c/image%204.png)

이때 원래의 해석적인 공식은 아래와 같다. 

![image.png](%EC%9E%90%EB%8F%99%EC%A0%9C%EC%96%B4%20%EA%B3%BC%EC%A0%9C%202%20Sol%2018044cd8bc5380b5bcf9f0238fa0735c/image%205.png)

## 5. Drawing exercise.

다음 전달함수의 스텝응답을 스케치하시오.

$$
G(s) = \frac{s/2 + 1}{(s/40+1)[(s/4)^2  + s/4 +1]}
$$

- Sol
    
    컴퓨터를 사용하지 말라는 말이 없으므로 컴퓨터를 적극적으로 사용해보자
    
    [https://supersonic.streamlit.app/%EC%A0%9C%EC%96%B4%EA%B8%B0%EA%B3%84%EC%82%B0%EA%B8%B0?embed=true](https://supersonic.streamlit.app/%EC%A0%9C%EC%96%B4%EA%B8%B0%EA%B3%84%EC%82%B0%EA%B8%B0?embed=true)
    
    여기에서, 아무것도 건드리지 말고 $G(s)$ 와 $H(s)$ 에 아래의 코드를 입력하자. 
    
    ```jsx
    G(s) 에는
    (분자항)
    16 * (0.5s  + 1)
    (분모항)
    (0.025 s + 1)(s2 + 4s + 16)
    
    H(s)에는
    
    (분자항)
    0
    (분모항)
    1
    ```
    
    ![image.png](%EC%9E%90%EB%8F%99%EC%A0%9C%EC%96%B4%20%EA%B3%BC%EC%A0%9C%202%20Sol%2018044cd8bc5380b5bcf9f0238fa0735c/image%206.png)
    

## 6. Final value theorem?

다음 식으로 표현되는 시스템 $G(s)$에 대해 단위 스텝 입력에 대한 출력을 $y(t)$라 하자.

$$
G(s) = \frac{1}{s-2}
$$

1. 최종값 정리(Final value theorem)를 이용하여 $y(\infty)$를 구하시오. 
2. Inverse Laplace Transform을 이용하여 y(t)를 계산하고 이를 이용해 $y(\infty)$ 를 수하시오. 
3. 위에서 계산한 두 결과가 같은지 확인해보고, 그 이유를 설명하시오.

## a. Sol

$$
\lim_{t \to \infty} y(t) = \lim_{s \to 0^+} s G(s) U(s) = \lim_{s \to 0^+} s \frac{1}{s - 2} = \lim_{s \to 0^+} \frac{s}{s - 2} = -\frac{1}{2}
$$

## b. Sol

$$
Y(s) = G(s) U(s) = \frac{1}{s(s - 2)} = \frac{1}{2} \left(\frac{1}{s - 2} - \frac{1}{s}\right)

\\

\mathcal{L}^{-1}(Y(s)) = \frac{1}{2} e^{2t} - \frac{1}{2} = y(t)
\\

\lim_{t \to \infty} y(t) = \infty
$$

## C. Sol

Final value theorem은 s-domain에서 정의된 Pole이 복소평면의 좌반면(LHP)에 있을 때 사용가능하지만, 위 $G(s)$의 pole은 s=2로써 우반면에 위치한다. 따라서 final value theorem을 사용할 수 없다. 

## 7. 로켓의 종방향 동역학(Short period)

짧은 시간 동안의 로켓의 피치방향 회전운동은 다음과 같은 식으로 표현할 수 있다.

![image.png](%EC%9E%90%EB%8F%99%EC%A0%9C%EC%96%B4%20%EA%B3%BC%EC%A0%9C%202%20Sol%2018044cd8bc5380b5bcf9f0238fa0735c/image%207.png)

위의 미분방정식은 $δ$를 입력으로 갖는 상태변수 $x =[α,q]^T$ 의 선형동역학을 기술하고
있음을 알 수 있으며, 각 변수의 설명은 다음과 같다.

- $\alpha$ : 받음각, 로켓의 동체축과 속도벡터 사이의 각
- $q$ : 피치방향 각속도
- $\delta$ :  조종날개 구동각
- $Z_α, Z_δ, M_α, M_q, M_δ$ : 로켓의 동역학을 기술하는 상수들.

 

![image.png](%EC%9E%90%EB%8F%99%EC%A0%9C%EC%96%B4%20%EA%B3%BC%EC%A0%9C%202%20Sol%2018044cd8bc5380b5bcf9f0238fa0735c/image%208.png)

a) 입력 $δ$ 에 대한 $q$ 의 동역학을 나타내는 전달 함수를 구하시오.

- Sol
    
    Linear equation에 대해서도 라플라스 변환을 적용할 수 있다. 
    
    $\dot{x} = Ax + Bu$ 라 하자.
    
    이때 위와 같은 선형 방정식에 라플라스 변환을 사용한다면
    
    $(sI-A)x = Bu$ 가 된다. 
    
    이때 $x = (sI-A)^{-1}Bu$ 이고 2by2 matrix의 inverse 공식은 알려져있으므로 적용하면 아래와 같다. 
    

 c) 로켓의 상태변수 α, q가 모두 0인 어떠한 고요한 비행조건에 대해 Zα = −1, Mα =
12, Mq = −2이라고 한다. 이 때 약한 바람이 불어 α != 0이 순간적으로 발생했다고
하면, 이후에 이 로켓은 어떻게 될까? 여기서 δ는 항상 0을 유지한다고 가정한다.

- Sol
    
    
    이때 시스템의 특성방정식 det를 통해 안정성을 판별하는 것과, 실제 라플라스 역변환을 통해 해석적인 해를 구하는 방법 두가지로 계산할 수 있다.
    
    ### 1. Determinants 를 통해 계산하는 방법
    
    ---
    
    행렬의 Determinant 는 아래와 같이 생각해볼 수 있다. 
    
    인하대 항공우주공학과의 응용선형대수 수업에선 Determinant를 따로 다루지는 않았지만 배웠던 것을 통해 유도해볼 수 있다. 
    
    $$
    Ax = 0
    $$
    
    정방행렬(Square matrix) $A$와 벡터 $0$에 대한 위와 같은 식이 존재할 때, $x$가 0이 아니라고 해보자. 
    
    그러면 선형 독립의 정의에 의해 $A$의 열벡터(Column vector)들은 선형 독립(linearly independent)이 아닌 선형 종속(linearly dependent) 관계이다. 
    
    이는 $A$의 역행렬이 존재할 수 없다는 것을 의미한다.
    
    이제 고유벡터와 고유값에 대해서 생각해보자. 
    
    $$
    Ax = \lambda x
    $$
    
    위 식을 만족시키는 정방행렬 $A$와 스칼라 $\lambda$가 존재한다고 해보자. 
    
    그러면 스칼라 $\lambda$를 **Eigenvalue(고유값)이라 하고**
    
    벡터 $x$를 **Eigenvector(고유벡터) 라 한다.**
    
    이제 이 식을 정리하면
    
    $$
    (A-\lambda)x = 0
    $$
    
    이 식을 만족시켜야 함을 알 수 있다. 
    
    이때 $A-\lambda$가 선형 종속이 되어야 0이 아닌 벡터 $x$가 존재하게 되고
    
    이에 대한 $\lambda$를 구하는 것이 $det$ 연산자이다.
    
    여기까지만 하고 $det$로 선형 동역학 시스템의 안정성을 판별하는 방법에 대해서 설명하겠다. 
    
    ### Appendix: 파이썬을 이용한 검증
    
    ```python
    import numpy as np
    import matplotlib.pyplot as plt
    
    # 상태 미분 함수
    def diff(z, par, delta):
        """
        z_dot 계산 (상태 변화율)
        z: 상태 벡터 (numpy array)
        par: 파라미터 딕셔너리 (A와 B 포함)
        delta: 입력 (조종면 각도)
        """
        z_dot = par["A"] @ z + par["B"] * delta
        return z_dot
    
    # 시뮬레이터 함수
    def simulator(z_init, dt, n, par):
        """
        상태 시뮬레이션 (오일러 방법 사용)
        z_init: 초기 상태 벡터
        dt: 시간 간격
        n: 시뮬레이션 스텝 수
        par: 파라미터 딕셔너리
        """
        # 상태 저장 배열 초기화
        Z_total = np.zeros((n + 1, len(z_init)))
        Z_total[0] = z_init  # 초기 상태 저장
        
        delta = 0  # 입력 값 (문제에 의거하여 0으로 설정, 제어기를 만들어서 검증해볼수도 있음)
    
        # 시간에 따라 상태 업데이트
        for i in range(n):
            Z_total[i + 1] = Z_total[i] + dt * diff(Z_total[i], par, delta)
    
        # 시간 벡터 생성
        time = np.array([dt * i for i in range(n + 1)])
        return Z_total, time
    
    # 파라미터 설정
    par = {
        "A": np.array([[-1, 1], [12, -2]]),  # 시스템 행렬
        "B": np.array([0, 0])  # 입력 행렬
    }
    #alpha의 초기값 설정
    alpha_0 = 0.1
    z_init = np.array([alpha_0, 0])  # 초기 상태: [alpha(0), q(0)]
    dt = 0.01  # 시간 간격
    n = 1000  # 시뮬레이션 스텝 수
    
    # 시뮬레이션 실행
    Z, t = simulator(z_init, dt, n, par)
    
    # 해석적 해
    alpha_analytic = 0.057143 * np.exp(2 * t) + 0.042857 * np.exp(-5 * t)
    q_analytic = 3 * (0.057143) * np.exp(2 * t) - 4 * (0.042857) * np.exp(-5 * t)
    
    # alpha 비교 그래프
    plt.plot(t, Z[:, 0], label="Numeric (alpha)")
    plt.plot(t, alpha_analytic, label="Analytic (alpha)")
    plt.legend()
    plt.grid()
    plt.title("Alpha (Numeric vs Analytic)")
    plt.xlabel("Time (s)")
    plt.ylabel("Alpha")
    plt.show()
    
    # q 비교 그래프
    plt.plot(t, Z[:, 1], label="Numeric (q)")
    plt.plot(t, q_analytic, label="Analytic (q)")
    plt.legend()
    plt.grid()
    plt.title("q (Numeric vs Analytic)")
    plt.xlabel("Time (s)")
    plt.ylabel("q")
    plt.show()
    ```
    
    이걸 실행시켜보면
    
    ![image.png](%EC%9E%90%EB%8F%99%EC%A0%9C%EC%96%B4%20%EA%B3%BC%EC%A0%9C%202%20Sol%2018044cd8bc5380b5bcf9f0238fa0735c/image%209.png)
    
    ![image.png](%EC%9E%90%EB%8F%99%EC%A0%9C%EC%96%B4%20%EA%B3%BC%EC%A0%9C%202%20Sol%2018044cd8bc5380b5bcf9f0238fa0735c/image%2010.png)